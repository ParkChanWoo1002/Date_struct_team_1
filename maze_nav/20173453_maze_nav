//maze
#include <iostream>
#include <stack>
using namespace std;
const int MAXSIZE = 100;
bool maze[MAXSIZE + 2][MAXSIZE + 2] = { 0 };	//
bool mark[MAXSIZE + 1][MAXSIZE + 1] = { 0 };	//

enum directions { N, NE, E, SE, S, SW, W, NW };	// enum 사용법
struct offsets
{
	int a, b;
}m_ove[8] = { -1,0, -1,1, 0,1, 1,1, 1,0, 1,-1, 0,-1, -1,-1 };

struct Items
{
	Items(int xx = 0, int yy = 0, int dd = 0) :x(xx), y(yy), dir(dd) {}
	int x, y, dir;
};

template<class T>
ostream& operator<<(ostream& os, stack<T>& s) {

	stack<T> tmp;			// 저장할 stack 임시 생성
	while (!s.empty()) {	// s의 stack을 temp로 옮기는 과정
		tmp.push(s.top());	// temp에 넣고
		s.pop();			// s거 pop
	}
	while (!tmp.empty()) {	// temp의 stack을 출력
		os << "->";
		os << tmp.top();	
		tmp.pop();
	}
	return os;
}

ostream& operator<<(ostream& os, Items& item) {
	static int count = 0;
	os << "(" << item.x << "," << item.y << ")";
	count++; if ((count % 5) == 0)os << endl; // 5개씩 끊기 무시
	return os;
}

void Path(const int m, const int p) {
	mark[1][1] = 1; // 출발 지점 1체크!
	stack<Items>  istack;
	Items temp(1, 1, E);	// 오른쪽부터 체크하기
	istack.push(temp);

	int node = 1; // 노드갯수 세기, 시작점 포함 1시작

	while (!istack.empty()) {
		temp = istack.top();	// 맨위 스택 저장하고
		istack.pop();			// 삭제하기
		int i = temp.x; int j = temp.y; int d = temp.dir;

		while (d < 8) {
			int g = i + m_ove[d].a; int h = j + m_ove[d].b;	// g,h 는 이동후 x,y 좌표
			if ((g == m) && (h == p)) {
				cout << istack;
				node++;			// 도착한것도 노드 1 추가해주기
				temp.x = i;  temp.y = j; cout << "->" << temp;
				temp.x = m;  temp.y = p; cout << "->" << temp << endl;
				cout << "방문한 노드수 = " << node << endl;
				return;  // 프로그램 종료
			}
			if ((!maze[g][h]) && (!mark[g][h])) { // 둘다 0 이 아닌경우, 방문하지도 않았고, 지도상으로도 0인경우
				mark[g][h] = 1;	// 방문해서 1
				node++;			// 방문했으니 node++
				temp.x = i; temp.y = j; temp.dir = d + 1; // 
				istack.push(temp);		// 스택에 추가
				i = g; j = h; d = N;	// (g,h) 로 이동
			}
			else d++; // 다음 방향으로 시도
		}// while
	}//while
	cout << "길이 없습니다" << endl;
}

void getdata(istream& is, int& m, int& p) {
	is >> m >> p;
	for (int i = 0; i < m + 2; i++)
	{
		maze[i][0] = 1; maze[i][p + 1] = 1;
	}		// 왼쪽 벽과 오른쪽 벽 작성
	for (int j = 1; j <= p; j++)
	{
		maze[0][j] = 1; maze[m + 1][j] = 1;
	}		// 윗쪽 벽과 아래쪽 벽 작성
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= p; j++)			// 자료 읽어들이기
			is >> maze[i][j];
	}
}


//main

#include <iostream>
#include <fstream>
using namespace std;
void getdata(istream&, int&, int&);
void Path(int, int);

int main(int argc, char* argv[]) {

	int m, p;
	if (argc == 1)
		cerr << "Usage" << argv[0] << "maze_data_file\n";
	else {
		ifstream is(argv[1]);
		if (!is) {
			cerr << argv[1] << "does ot exist\n";
			return 1;
		}
		cout << "For maze datafile [" << argv[1] << "]\n";
		getdata(is, m, p); is.close();
		Path(m, p);
	}
}






